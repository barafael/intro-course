{
  "snippets": {
    "projects/discriminated_union/disc_union/disc_union.h": {
      "disc_union_tag_enum": {
        "content": "typedef enum Value_Tag {\n  Null,\n  Bool,\n  Number,\n  String,\n} Value_Tag;",
        "file": "projects/discriminated_union/disc_union/disc_union.h",
        "line": 10,
        "col": 0
      }
    },
    "projects/discriminated_union/src/lib.rs": {
      "disc_union_enum": {
        "content": "#[repr(C)]\n#[derive(Debug)]\npub enum Value {\n    Null,\n    Bool(bool),\n    Number(f64),\n    String(*const c_char),\n    // Array(Vec<Value>),\n    // Object(HashMap<CString, Box<Value>>),\n}",
        "file": "projects/discriminated_union/src/lib.rs",
        "line": 10,
        "col": 0
      }
    },
    "projects/fizzbuzz_iterator/src/lib.rs": {
      "first_20_elems": {
        "content": "        let fizzbuzz = Fizzbuzz::default();\n        fizzbuzz.take(20).for_each(|elem| {\n            println!(\"{elem}\");\n        })",
        "file": "projects/fizzbuzz_iterator/src/lib.rs",
        "line": 28,
        "col": 0
      },
      "fizzbuzz_iterator_trait_impl_1": {
        "content": "impl Iterator for Fizzbuzz {\n    type Item = String;",
        "file": "projects/fizzbuzz_iterator/src/lib.rs",
        "line": 5,
        "col": 0
      },
      "fizzbuzz_iterator_trait_impl_2": {
        "content": "    fn next(&mut self) -> Option<Self::Item> {\n        self.0 += 1;\n        match (self.0 % 3 == 0, self.0 % 5 == 0) {\n            (true, true) => Some(\"Fizzbuzz!\".to_string()),\n            (false, true) => Some(\"Fizz\".to_string()),\n            (true, false) => Some(\"Buzz\".to_string()),\n            _ => Some(format!(\"{}\", self.0)),\n        }\n    }",
        "file": "projects/fizzbuzz_iterator/src/lib.rs",
        "line": 9,
        "col": 0
      },
      "fizzbuzz_struct": {
        "content": "#[derive(Default)]\nstruct Fizzbuzz(u64);",
        "file": "projects/fizzbuzz_iterator/src/lib.rs",
        "line": 0,
        "col": 0
      }
    },
    "projects/maybe/src/lib.rs": {
      "enum_type_maybe": {
        "content": "pub enum Maybe<T> {\n    Just(T),\n    Nothing,\n}",
        "file": "projects/maybe/src/lib.rs",
        "line": 1,
        "col": 0
      },
      "enum_type_maybe_match": {
        "content": "        match it {\n            Maybe::Just(\"something\") => println!(\"found \\\"something\\\"!\"),\n            Maybe::Just(\"data!\") => println!(\"found \\\"data!\\\"\"),\n            Maybe::Just(something_else) => println!(\"found {something_else}!\"),\n            Maybe::Nothing => println!(\"there was nothing in it...\"),\n        }",
        "file": "projects/maybe/src/lib.rs",
        "line": 54,
        "col": 0
      },
      "maybe_fn": {
        "content": "    pub fn is_just(&self) -> bool {\n        matches!(self, &Maybe::Just(_))\n    }",
        "file": "projects/maybe/src/lib.rs",
        "line": 18,
        "col": 0
      },
      "maybe_fn_mut": {
        "content": "    pub fn take(&mut self) -> Maybe<T> {\n        std::mem::replace(self, Maybe::Nothing)\n    }",
        "file": "projects/maybe/src/lib.rs",
        "line": 24,
        "col": 0
      },
      "maybe_fn_once": {
        "content": "    pub fn unwrap(self) -> T {\n        match self {\n            Maybe::Just(t) => t,\n            Maybe::Nothing => panic!(\"`unwrap` on a `Maybe::Nothing`!\"),\n        }\n    }",
        "file": "projects/maybe/src/lib.rs",
        "line": 9,
        "col": 0
      },
      "maybe_type_enum_sizes": {
        "content": "        print_type_info(&Maybe::Just(1u8));\n        print_type_info(&Maybe::<u16>::Nothing);\n        print_type_info(&Maybe::Just(false));",
        "file": "projects/maybe/src/lib.rs",
        "line": 66,
        "col": 0
      },
      "maybe_type_iflet": {
        "content": "        if let Maybe::Just(data) = it {\n            println!(\"got some data: {data:?}\");\n        } else {\n            println!(\"there's nothing in it.\");\n        }",
        "file": "projects/maybe/src/lib.rs",
        "line": 42,
        "col": 0
      },
      "maybe_type_size_of_boxes": {
        "content": "        print_type_info(&Maybe::Just(Box::new(8)));\n        print_type_info(&Maybe::Just(Arc::new(ErrorKind::AddrInUse)));\n        print_type_info(&Maybe::<Box<String>>::Nothing);",
        "file": "projects/maybe/src/lib.rs",
        "line": 84,
        "col": 0
      },
      "maybe_type_size_of_references": {
        "content": "        print_type_info(&Maybe::Just(&1u8));\n        print_type_info(&Maybe::Just(&[2u64]));\n        print_type_info(&Maybe::<&str>::Nothing);",
        "file": "projects/maybe/src/lib.rs",
        "line": 75,
        "col": 0
      }
    },
    "projects/simple_server/src/main.rs": {
      "break_loop_with_value": {
        "content": "    loop {\n        if let Ok(bytes_read) = reader.read_line(&mut line).await {\n            if bytes_read == 0 {\n                break Ok(());\n            }",
        "file": "projects/simple_server/src/main.rs",
        "line": 90,
        "col": 0
      },
      "mutable_binding_in_destructuring_pattern": {
        "content": "        let (mut socket, addr) = listener\n            .accept()\n            .await\n            .context(\"Failed to accept on socket\")?;",
        "file": "projects/simple_server/src/main.rs",
        "line": 58,
        "col": 0
      },
      "server_cliche_loop": {
        "content": "    loop {\n        // marker-start:mutable_binding_in_destructuring_pattern\n        let (mut socket, addr) = listener\n            .accept()\n            .await\n            .context(\"Failed to accept on socket\")?;\n        // marker-end:mutable_binding_in_destructuring_pattern\n\n        let tx = tx.clone();\n\n        tokio::spawn(async move {\n            let (reader, writer) = socket.split();\n            handle_connection(addr.to_string(), reader, writer, tx)\n                .await\n                .expect(\"Failed to handle connection\");\n        });\n    }",
        "file": "projects/simple_server/src/main.rs",
        "line": 56,
        "col": 0
      }
    },
    "projects/simple_snippets/src/lib.rs": {
      "config_leak": {
        "content": "        let config = Config::load_from_disk()?;\n        let config: &'static _ = Box::leak(Box::new(config));\n        dbg!(config); // config may now be handed out among threads.",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 85,
        "col": 0
      },
      "find_tv_fn": {
        "content": "        fn find_tv<'a>(input: &'a str) -> Option<Selection<'a>> {\n            input\n                .split_whitespace()\n                .find(|token| token.contains(\"television\"))\n                .map(Selection)\n        }",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 36,
        "col": 0
      },
      "selection_struct": {
        "content": "        #[derive(Debug)]\n        struct Selection<'a>(&'a str);",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 31,
        "col": 0
      },
      "serde_deserialize_with_shared_references_1": {
        "content": "        #[derive(Debug, Deserialize, Serialize)]\n        struct Item<'a, 'b> {\n            name: &'a str,\n            description: &'b str,\n        }",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 54,
        "col": 0
      },
      "serde_deserialize_with_shared_references_2": {
        "content": "        let input = String::from(\n            r#\"{\n            \"name\":\"toothbrush\",\n            \"description\":\"used, good condition\"\n        }\"#,\n        );\n        let item: Item = serde_json::from_str(&input).unwrap();\n        //drop(input); // UNCOMMENT THIS\n        dbg!(item);",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 61,
        "col": 0
      },
      "sharing_data_with_threads": {
        "content": "        let data: &str = \"this is data!\";\n        let handle_1 = std::thread::spawn(move || {\n            println!(\"data 1: {data}\");\n        });",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 16,
        "col": 0
      },
      "simple_mutex": {
        "content": "        let value = Mutex::new(5);\n        let mut guard: MutexGuard<'_, i32> = value.lock().unwrap();\n        *guard = 1;\n        dbg!(*guard);",
        "file": "projects/simple_snippets/src/lib.rs",
        "line": 6,
        "col": 0
      }
    },
    "projects/simple_tests/Cargo.toml": {
      "dev_dependencies_proptest": {
        "content": "[dev-dependencies]\nproptest = \"1\"",
        "file": "projects/simple_tests/Cargo.toml",
        "line": 5,
        "col": 0
      }
    },
    "projects/simple_tests/src/lib.rs": {
      "any_strategy_proptest": {
        "content": "        #[test]\n        fn should_map_any_i32(a in any::<i32>()) {\n            assert_eq!(a, identity(a));\n        }",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 71,
        "col": 0
      },
      "identity_fn": {
        "content": "pub fn identity<T>(elem: T) -> T {\n    elem\n}",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 12,
        "col": 0
      },
      "simple_doctest": {
        "content": "/// An identity function.\n///\n/// ````rust\n/// use simple_tests::identity;\n///\n/// let x = 4;\n/// assert_eq!(identity(&x), &4);\n/// ````",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 2,
        "col": 0
      },
      "simple_proptest": {
        "content": "        #[test]\n        fn should_map_small_i32(a in 0..1000i32) {\n            assert_eq!(a, identity(a));\n        }",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 64,
        "col": 0
      },
      "test_module": {
        "content": "#[cfg(test)]\nmod test {\n    use super::*;",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 26,
        "col": 0
      },
      "test_should_map_function_pointer": {
        "content": "    // #[test]\n    // fn should_map_function_pointer() {\n    //     let id = &identity::<bool>;\n    //     assert_eq!(id, identity(id));\n    // }",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 40,
        "col": 0
      },
      "test_should_map_integers": {
        "content": "    #[test]\n    fn should_map_integers() {\n        assert!(identity(3) == 3);\n        assert_eq!(4, identity(4));\n    }",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 32,
        "col": 0
      },
      "test_should_panic": {
        "content": "    #[allow(unconditional_panic)]\n    #[test]\n    #[should_panic(expected = \"attempt to divide by zero\")]\n    fn refuses_to_divide_by_zero() {\n        let n = rand::random::<i8>();\n        // let n  = 0;\n        let _ = n / 0;\n    }",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 48,
        "col": 0
      },
      "vec_strategy_proptest": {
        "content": "        #[test]\n        fn should_map_vec_elems(a in prop::collection::vec(any::<u128>(), 1..1000)) {\n            assert!(a.into_iter().all(|elem| elem == identity(elem)));\n        }",
        "file": "projects/simple_tests/src/lib.rs",
        "line": 78,
        "col": 0
      }
    },
    "projects/to_byte_slice/src/lib.rs": {
      "print_meta": {
        "content": "        let a = A(1, 2, 4);\n        print_type_info(&a);",
        "file": "projects/to_byte_slice/src/lib.rs",
        "line": 31,
        "col": 0
      },
      "print_meta_packed": {
        "content": "        let a = A(1, 2, 4);\n        print_type_info(&a);",
        "file": "projects/to_byte_slice/src/lib.rs",
        "line": 44,
        "col": 0
      },
      "simple_badly_aligned_reprc_struct": {
        "content": "        #[repr(C)]\n        struct A(u8, u8, u32);",
        "file": "projects/to_byte_slice/src/lib.rs",
        "line": 26,
        "col": 0
      },
      "simple_badly_aligned_reprpacked_struct": {
        "content": "        #[repr(packed)]\n        struct A(u8, u8, u32);",
        "file": "projects/to_byte_slice/src/lib.rs",
        "line": 39,
        "col": 0
      }
    },
    "projects/traffic_light/src/main.rs": {
      "traffic_light_consume": {
        "content": "impl TrafficLight<Yellow> {\n    pub fn red(self) -> TrafficLight<Red> {\n        TrafficLight {\n            marker: PhantomData::<Red>,\n        }\n    }\n}",
        "file": "projects/traffic_light/src/main.rs",
        "line": 55,
        "col": 0
      },
      "traffic_light_default": {
        "content": "impl Default for TrafficLight<Red> {\n    fn default() -> Self {\n        TrafficLight {\n            marker: PhantomData::<Red>,\n        }\n    }\n}",
        "file": "projects/traffic_light/src/main.rs",
        "line": 29,
        "col": 0
      },
      "traffic_light_display": {
        "content": "impl Display for TrafficLight<Red> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"Red traffic light\")\n    }\n}",
        "file": "projects/traffic_light/src/main.rs",
        "line": 39,
        "col": 0
      }
    }
  }
}